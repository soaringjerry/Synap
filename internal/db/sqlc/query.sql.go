// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqldb

import (
	"context"
	"database/sql"
	"time"
)

const createItem = `-- name: CreateItem :exec
INSERT INTO items (
  id, scale_id, reverse_scored, stem_i18n, type, options_i18n, placeholder_i18n,
  min_value, max_value, step_value, required, likert_labels_i18n, likert_show_numbers,
  position, created_at, updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP), COALESCE(?, CURRENT_TIMESTAMP)
)
`

type CreateItemParams struct {
	ID                string
	ScaleID           string
	ReverseScored     int64
	StemI18n          sql.NullString
	Type              sql.NullString
	OptionsI18n       sql.NullString
	PlaceholderI18n   sql.NullString
	MinValue          sql.NullInt64
	MaxValue          sql.NullInt64
	StepValue         sql.NullInt64
	Required          int64
	LikertLabelsI18n  sql.NullString
	LikertShowNumbers int64
	Position          int64
	Column15          interface{}
	Column16          interface{}
}

// Items
func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) error {
	_, err := q.db.ExecContext(ctx, createItem,
		arg.ID,
		arg.ScaleID,
		arg.ReverseScored,
		arg.StemI18n,
		arg.Type,
		arg.OptionsI18n,
		arg.PlaceholderI18n,
		arg.MinValue,
		arg.MaxValue,
		arg.StepValue,
		arg.Required,
		arg.LikertLabelsI18n,
		arg.LikertShowNumbers,
		arg.Position,
		arg.Column15,
		arg.Column16,
	)
	return err
}

const createParticipant = `-- name: CreateParticipant :exec
INSERT INTO participants (id, email, self_token, consent_id, created_at)
VALUES (?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP))
`

type CreateParticipantParams struct {
	ID        string
	Email     sql.NullString
	SelfToken sql.NullString
	ConsentID sql.NullString
	Column5   interface{}
}

// Participants
func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) error {
	_, err := q.db.ExecContext(ctx, createParticipant,
		arg.ID,
		arg.Email,
		arg.SelfToken,
		arg.ConsentID,
		arg.Column5,
	)
	return err
}

const createScale = `-- name: CreateScale :exec
INSERT INTO scales (
  id, tenant_id, points, randomize, name_i18n, consent_i18n, collect_email,
  e2ee_enabled, region, turnstile_enabled, items_per_page, consent_config,
  likert_labels_i18n, likert_show_numbers, likert_preset, created_at, updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP), COALESCE(?, CURRENT_TIMESTAMP)
)
`

type CreateScaleParams struct {
	ID                string
	TenantID          string
	Points            int64
	Randomize         int64
	NameI18n          sql.NullString
	ConsentI18n       sql.NullString
	CollectEmail      sql.NullString
	E2eeEnabled       int64
	Region            sql.NullString
	TurnstileEnabled  int64
	ItemsPerPage      sql.NullInt64
	ConsentConfig     sql.NullString
	LikertLabelsI18n  sql.NullString
	LikertShowNumbers int64
	LikertPreset      sql.NullString
	Column16          interface{}
	Column17          interface{}
}

// Scales
func (q *Queries) CreateScale(ctx context.Context, arg CreateScaleParams) error {
	_, err := q.db.ExecContext(ctx, createScale,
		arg.ID,
		arg.TenantID,
		arg.Points,
		arg.Randomize,
		arg.NameI18n,
		arg.ConsentI18n,
		arg.CollectEmail,
		arg.E2eeEnabled,
		arg.Region,
		arg.TurnstileEnabled,
		arg.ItemsPerPage,
		arg.ConsentConfig,
		arg.LikertLabelsI18n,
		arg.LikertShowNumbers,
		arg.LikertPreset,
		arg.Column16,
		arg.Column17,
	)
	return err
}

const createTenant = `-- name: CreateTenant :exec
INSERT INTO tenants (id, name, created_at) VALUES (?, ?, COALESCE(?, CURRENT_TIMESTAMP))
`

type CreateTenantParams struct {
	ID      string
	Name    string
	Column3 interface{}
}

// Tenants
func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) error {
	_, err := q.db.ExecContext(ctx, createTenant, arg.ID, arg.Name, arg.Column3)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, email, pass_hash, tenant_id, created_at) VALUES (?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP))
`

type CreateUserParams struct {
	ID       string
	Email    string
	PassHash []byte
	TenantID string
	Column5  interface{}
}

// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PassHash,
		arg.TenantID,
		arg.Column5,
	)
	return err
}

const deleteConsentRecordsByScale = `-- name: DeleteConsentRecordsByScale :exec
DELETE FROM consent_records WHERE scale_id = ?
`

func (q *Queries) DeleteConsentRecordsByScale(ctx context.Context, scaleID string) error {
	_, err := q.db.ExecContext(ctx, deleteConsentRecordsByScale, scaleID)
	return err
}

const deleteE2EEResponse = `-- name: DeleteE2EEResponse :exec
DELETE FROM e2ee_responses WHERE response_id = ?
`

func (q *Queries) DeleteE2EEResponse(ctx context.Context, responseID string) error {
	_, err := q.db.ExecContext(ctx, deleteE2EEResponse, responseID)
	return err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM items WHERE id = ?
`

func (q *Queries) DeleteItem(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteItem, id)
	return err
}

const deleteParticipant = `-- name: DeleteParticipant :exec
DELETE FROM participants WHERE id = ?
`

func (q *Queries) DeleteParticipant(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteParticipant, id)
	return err
}

const deleteResponsesByParticipant = `-- name: DeleteResponsesByParticipant :exec
DELETE FROM responses WHERE participant_id = ?
`

func (q *Queries) DeleteResponsesByParticipant(ctx context.Context, participantID string) error {
	_, err := q.db.ExecContext(ctx, deleteResponsesByParticipant, participantID)
	return err
}

const deleteResponsesByScale = `-- name: DeleteResponsesByScale :exec
DELETE FROM responses WHERE scale_id = ?
`

func (q *Queries) DeleteResponsesByScale(ctx context.Context, scaleID string) error {
	_, err := q.db.ExecContext(ctx, deleteResponsesByScale, scaleID)
	return err
}

const deleteScale = `-- name: DeleteScale :exec
DELETE FROM scales WHERE id = ?
`

func (q *Queries) DeleteScale(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteScale, id)
	return err
}

const getAIConfig = `-- name: GetAIConfig :one
SELECT tenant_id, openai_key, openai_base, allow_external, store_logs, updated_at FROM tenant_ai_configs WHERE tenant_id = ?
`

// AI config
func (q *Queries) GetAIConfig(ctx context.Context, tenantID string) (TenantAiConfig, error) {
	row := q.db.QueryRowContext(ctx, getAIConfig, tenantID)
	var i TenantAiConfig
	err := row.Scan(
		&i.TenantID,
		&i.OpenaiKey,
		&i.OpenaiBase,
		&i.AllowExternal,
		&i.StoreLogs,
		&i.UpdatedAt,
	)
	return i, err
}

const getConsentRecord = `-- name: GetConsentRecord :one
SELECT id, scale_id, version, choices, locale, signed_at, hash FROM consent_records WHERE id = ?
`

func (q *Queries) GetConsentRecord(ctx context.Context, id string) (ConsentRecord, error) {
	row := q.db.QueryRowContext(ctx, getConsentRecord, id)
	var i ConsentRecord
	err := row.Scan(
		&i.ID,
		&i.ScaleID,
		&i.Version,
		&i.Choices,
		&i.Locale,
		&i.SignedAt,
		&i.Hash,
	)
	return i, err
}

const getE2EEResponse = `-- name: GetE2EEResponse :one
SELECT response_id, scale_id, ciphertext, nonce, aad_hash, enc_dek, pmk_fingerprint, created_at, self_token
FROM e2ee_responses WHERE response_id = ?
`

func (q *Queries) GetE2EEResponse(ctx context.Context, responseID string) (E2eeResponse, error) {
	row := q.db.QueryRowContext(ctx, getE2EEResponse, responseID)
	var i E2eeResponse
	err := row.Scan(
		&i.ResponseID,
		&i.ScaleID,
		&i.Ciphertext,
		&i.Nonce,
		&i.AadHash,
		&i.EncDek,
		&i.PmkFingerprint,
		&i.CreatedAt,
		&i.SelfToken,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT id, scale_id, reverse_scored, stem_i18n, type, options_i18n, placeholder_i18n,
       min_value, max_value, step_value, required, likert_labels_i18n,
       likert_show_numbers, position, created_at, updated_at
FROM items WHERE id = ?
`

func (q *Queries) GetItem(ctx context.Context, id string) (Item, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.ScaleID,
		&i.ReverseScored,
		&i.StemI18n,
		&i.Type,
		&i.OptionsI18n,
		&i.PlaceholderI18n,
		&i.MinValue,
		&i.MaxValue,
		&i.StepValue,
		&i.Required,
		&i.LikertLabelsI18n,
		&i.LikertShowNumbers,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getParticipant = `-- name: GetParticipant :one
SELECT id, email, self_token, consent_id, created_at FROM participants WHERE id = ?
`

func (q *Queries) GetParticipant(ctx context.Context, id string) (Participant, error) {
	row := q.db.QueryRowContext(ctx, getParticipant, id)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.SelfToken,
		&i.ConsentID,
		&i.CreatedAt,
	)
	return i, err
}

const getParticipantByEmail = `-- name: GetParticipantByEmail :one
SELECT id, email, self_token, consent_id, created_at FROM participants WHERE LOWER(email) = LOWER(?) LIMIT 1
`

func (q *Queries) GetParticipantByEmail(ctx context.Context, lower string) (Participant, error) {
	row := q.db.QueryRowContext(ctx, getParticipantByEmail, lower)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.SelfToken,
		&i.ConsentID,
		&i.CreatedAt,
	)
	return i, err
}

const getScale = `-- name: GetScale :one
SELECT id, tenant_id, points, randomize, name_i18n, consent_i18n, collect_email,
       e2ee_enabled, region, turnstile_enabled, items_per_page, consent_config,
       likert_labels_i18n, likert_show_numbers, likert_preset, created_at, updated_at
FROM scales WHERE id = ?
`

func (q *Queries) GetScale(ctx context.Context, id string) (Scale, error) {
	row := q.db.QueryRowContext(ctx, getScale, id)
	var i Scale
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Points,
		&i.Randomize,
		&i.NameI18n,
		&i.ConsentI18n,
		&i.CollectEmail,
		&i.E2eeEnabled,
		&i.Region,
		&i.TurnstileEnabled,
		&i.ItemsPerPage,
		&i.ConsentConfig,
		&i.LikertLabelsI18n,
		&i.LikertShowNumbers,
		&i.LikertPreset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, pass_hash, tenant_id, created_at FROM users WHERE LOWER(email) = LOWER(?) LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PassHash,
		&i.TenantID,
		&i.CreatedAt,
	)
	return i, err
}

const insertAudit = `-- name: InsertAudit :exec
INSERT INTO audit_log (ts, actor, action, target, note) VALUES (COALESCE(?, CURRENT_TIMESTAMP), ?, ?, ?, ?)
`

type InsertAuditParams struct {
	Column1 interface{}
	Actor   string
	Action  string
	Target  sql.NullString
	Note    sql.NullString
}

// Audit log
func (q *Queries) InsertAudit(ctx context.Context, arg InsertAuditParams) error {
	_, err := q.db.ExecContext(ctx, insertAudit,
		arg.Column1,
		arg.Actor,
		arg.Action,
		arg.Target,
		arg.Note,
	)
	return err
}

const insertConsentRecord = `-- name: InsertConsentRecord :exec
INSERT INTO consent_records (id, scale_id, version, choices, locale, signed_at, hash)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
  scale_id = excluded.scale_id,
  version = excluded.version,
  choices = excluded.choices,
  locale = excluded.locale,
  signed_at = excluded.signed_at,
  hash = excluded.hash
`

type InsertConsentRecordParams struct {
	ID       string
	ScaleID  string
	Version  sql.NullString
	Choices  sql.NullString
	Locale   sql.NullString
	SignedAt time.Time
	Hash     sql.NullString
}

// Consent records
func (q *Queries) InsertConsentRecord(ctx context.Context, arg InsertConsentRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertConsentRecord,
		arg.ID,
		arg.ScaleID,
		arg.Version,
		arg.Choices,
		arg.Locale,
		arg.SignedAt,
		arg.Hash,
	)
	return err
}

const insertE2EEResponse = `-- name: InsertE2EEResponse :exec
INSERT INTO e2ee_responses (
  response_id, scale_id, ciphertext, nonce, aad_hash, enc_dek, pmk_fingerprint, created_at, self_token
) VALUES (?, ?, ?, ?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP), ?)
ON CONFLICT(response_id) DO UPDATE SET
  scale_id = excluded.scale_id,
  ciphertext = excluded.ciphertext,
  nonce = excluded.nonce,
  aad_hash = excluded.aad_hash,
  enc_dek = excluded.enc_dek,
  pmk_fingerprint = excluded.pmk_fingerprint,
  self_token = excluded.self_token
`

type InsertE2EEResponseParams struct {
	ResponseID     string
	ScaleID        string
	Ciphertext     string
	Nonce          sql.NullString
	AadHash        sql.NullString
	EncDek         sql.NullString
	PmkFingerprint sql.NullString
	Column8        interface{}
	SelfToken      sql.NullString
}

// E2EE responses
func (q *Queries) InsertE2EEResponse(ctx context.Context, arg InsertE2EEResponseParams) error {
	_, err := q.db.ExecContext(ctx, insertE2EEResponse,
		arg.ResponseID,
		arg.ScaleID,
		arg.Ciphertext,
		arg.Nonce,
		arg.AadHash,
		arg.EncDek,
		arg.PmkFingerprint,
		arg.Column8,
		arg.SelfToken,
	)
	return err
}

const insertProjectKey = `-- name: InsertProjectKey :exec
INSERT INTO project_keys (scale_id, fingerprint, algorithm, kdf, public_key, created_at, disabled)
VALUES (?, ?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP), ?)
ON CONFLICT(scale_id, fingerprint) DO UPDATE SET
  algorithm = excluded.algorithm,
  kdf = excluded.kdf,
  public_key = excluded.public_key,
  disabled = excluded.disabled,
  created_at = CASE WHEN project_keys.created_at IS NULL THEN excluded.created_at ELSE project_keys.created_at END
`

type InsertProjectKeyParams struct {
	ScaleID     string
	Fingerprint string
	Algorithm   string
	Kdf         sql.NullString
	PublicKey   string
	Column6     interface{}
	Disabled    int64
}

// Project keys
func (q *Queries) InsertProjectKey(ctx context.Context, arg InsertProjectKeyParams) error {
	_, err := q.db.ExecContext(ctx, insertProjectKey,
		arg.ScaleID,
		arg.Fingerprint,
		arg.Algorithm,
		arg.Kdf,
		arg.PublicKey,
		arg.Column6,
		arg.Disabled,
	)
	return err
}

const insertResponse = `-- name: InsertResponse :exec
INSERT INTO responses (
  participant_id, item_id, scale_id, raw_value, score_value, submitted_at, raw_json
) VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(participant_id, item_id) DO UPDATE SET
  raw_value = excluded.raw_value,
  score_value = excluded.score_value,
  submitted_at = excluded.submitted_at,
  raw_json = excluded.raw_json
`

type InsertResponseParams struct {
	ParticipantID string
	ItemID        string
	ScaleID       string
	RawValue      sql.NullInt64
	ScoreValue    sql.NullInt64
	SubmittedAt   time.Time
	RawJson       sql.NullString
}

// Responses
func (q *Queries) InsertResponse(ctx context.Context, arg InsertResponseParams) error {
	_, err := q.db.ExecContext(ctx, insertResponse,
		arg.ParticipantID,
		arg.ItemID,
		arg.ScaleID,
		arg.RawValue,
		arg.ScoreValue,
		arg.SubmittedAt,
		arg.RawJson,
	)
	return err
}

const listAllE2EEResponses = `-- name: ListAllE2EEResponses :many
SELECT response_id, scale_id, ciphertext, nonce, aad_hash, enc_dek, pmk_fingerprint, created_at, self_token
FROM e2ee_responses ORDER BY created_at ASC
`

func (q *Queries) ListAllE2EEResponses(ctx context.Context) ([]E2eeResponse, error) {
	rows, err := q.db.QueryContext(ctx, listAllE2EEResponses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []E2eeResponse
	for rows.Next() {
		var i E2eeResponse
		if err := rows.Scan(
			&i.ResponseID,
			&i.ScaleID,
			&i.Ciphertext,
			&i.Nonce,
			&i.AadHash,
			&i.EncDek,
			&i.PmkFingerprint,
			&i.CreatedAt,
			&i.SelfToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAudit = `-- name: ListAudit :many
SELECT id, ts, actor, action, target, note FROM audit_log ORDER BY ts DESC, id DESC LIMIT ?
`

func (q *Queries) ListAudit(ctx context.Context, limit int64) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAudit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.Actor,
			&i.Action,
			&i.Target,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listE2EEResponsesByScale = `-- name: ListE2EEResponsesByScale :many
SELECT response_id, scale_id, ciphertext, nonce, aad_hash, enc_dek, pmk_fingerprint, created_at, self_token
FROM e2ee_responses WHERE scale_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListE2EEResponsesByScale(ctx context.Context, scaleID string) ([]E2eeResponse, error) {
	rows, err := q.db.QueryContext(ctx, listE2EEResponsesByScale, scaleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []E2eeResponse
	for rows.Next() {
		var i E2eeResponse
		if err := rows.Scan(
			&i.ResponseID,
			&i.ScaleID,
			&i.Ciphertext,
			&i.Nonce,
			&i.AadHash,
			&i.EncDek,
			&i.PmkFingerprint,
			&i.CreatedAt,
			&i.SelfToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByScale = `-- name: ListItemsByScale :many
SELECT id, scale_id, reverse_scored, stem_i18n, type, options_i18n, placeholder_i18n,
       min_value, max_value, step_value, required, likert_labels_i18n,
       likert_show_numbers, position, created_at, updated_at
FROM items WHERE scale_id = ? ORDER BY position ASC, id ASC
`

func (q *Queries) ListItemsByScale(ctx context.Context, scaleID string) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, listItemsByScale, scaleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.ScaleID,
			&i.ReverseScored,
			&i.StemI18n,
			&i.Type,
			&i.OptionsI18n,
			&i.PlaceholderI18n,
			&i.MinValue,
			&i.MaxValue,
			&i.StepValue,
			&i.Required,
			&i.LikertLabelsI18n,
			&i.LikertShowNumbers,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectKeys = `-- name: ListProjectKeys :many
SELECT scale_id, fingerprint, algorithm, kdf, public_key, created_at, disabled
FROM project_keys WHERE scale_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListProjectKeys(ctx context.Context, scaleID string) ([]ProjectKey, error) {
	rows, err := q.db.QueryContext(ctx, listProjectKeys, scaleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectKey
	for rows.Next() {
		var i ProjectKey
		if err := rows.Scan(
			&i.ScaleID,
			&i.Fingerprint,
			&i.Algorithm,
			&i.Kdf,
			&i.PublicKey,
			&i.CreatedAt,
			&i.Disabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResponsesByParticipant = `-- name: ListResponsesByParticipant :many
SELECT participant_id, item_id, scale_id, raw_value, score_value, submitted_at, raw_json
FROM responses WHERE participant_id = ? ORDER BY submitted_at ASC
`

func (q *Queries) ListResponsesByParticipant(ctx context.Context, participantID string) ([]Response, error) {
	rows, err := q.db.QueryContext(ctx, listResponsesByParticipant, participantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Response
	for rows.Next() {
		var i Response
		if err := rows.Scan(
			&i.ParticipantID,
			&i.ItemID,
			&i.ScaleID,
			&i.RawValue,
			&i.ScoreValue,
			&i.SubmittedAt,
			&i.RawJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResponsesByScale = `-- name: ListResponsesByScale :many
SELECT participant_id, item_id, scale_id, raw_value, score_value, submitted_at, raw_json
FROM responses WHERE scale_id = ? ORDER BY submitted_at ASC
`

func (q *Queries) ListResponsesByScale(ctx context.Context, scaleID string) ([]Response, error) {
	rows, err := q.db.QueryContext(ctx, listResponsesByScale, scaleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Response
	for rows.Next() {
		var i Response
		if err := rows.Scan(
			&i.ParticipantID,
			&i.ItemID,
			&i.ScaleID,
			&i.RawValue,
			&i.ScoreValue,
			&i.SubmittedAt,
			&i.RawJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScalesByTenant = `-- name: ListScalesByTenant :many
SELECT id, tenant_id, points, randomize, name_i18n, consent_i18n, collect_email,
       e2ee_enabled, region, turnstile_enabled, items_per_page, consent_config,
       likert_labels_i18n, likert_show_numbers, likert_preset, created_at, updated_at
FROM scales WHERE tenant_id = ? ORDER BY id
`

func (q *Queries) ListScalesByTenant(ctx context.Context, tenantID string) ([]Scale, error) {
	rows, err := q.db.QueryContext(ctx, listScalesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scale
	for rows.Next() {
		var i Scale
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Points,
			&i.Randomize,
			&i.NameI18n,
			&i.ConsentI18n,
			&i.CollectEmail,
			&i.E2eeEnabled,
			&i.Region,
			&i.TurnstileEnabled,
			&i.ItemsPerPage,
			&i.ConsentConfig,
			&i.LikertLabelsI18n,
			&i.LikertShowNumbers,
			&i.LikertPreset,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateE2EEEncDEK = `-- name: UpdateE2EEEncDEK :exec
UPDATE e2ee_responses SET enc_dek = ? WHERE response_id = ?
`

type UpdateE2EEEncDEKParams struct {
	EncDek     sql.NullString
	ResponseID string
}

func (q *Queries) UpdateE2EEEncDEK(ctx context.Context, arg UpdateE2EEEncDEKParams) error {
	_, err := q.db.ExecContext(ctx, updateE2EEEncDEK, arg.EncDek, arg.ResponseID)
	return err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE items SET
  stem_i18n = ?,
  reverse_scored = ?,
  type = ?,
  options_i18n = ?,
  placeholder_i18n = ?,
  min_value = ?,
  max_value = ?,
  step_value = ?,
  required = ?,
  likert_labels_i18n = ?,
  likert_show_numbers = ?,
  position = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateItemParams struct {
	StemI18n          sql.NullString
	ReverseScored     int64
	Type              sql.NullString
	OptionsI18n       sql.NullString
	PlaceholderI18n   sql.NullString
	MinValue          sql.NullInt64
	MaxValue          sql.NullInt64
	StepValue         sql.NullInt64
	Required          int64
	LikertLabelsI18n  sql.NullString
	LikertShowNumbers int64
	Position          int64
	ID                string
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.ExecContext(ctx, updateItem,
		arg.StemI18n,
		arg.ReverseScored,
		arg.Type,
		arg.OptionsI18n,
		arg.PlaceholderI18n,
		arg.MinValue,
		arg.MaxValue,
		arg.StepValue,
		arg.Required,
		arg.LikertLabelsI18n,
		arg.LikertShowNumbers,
		arg.Position,
		arg.ID,
	)
	return err
}

const updateItemPosition = `-- name: UpdateItemPosition :exec
UPDATE items SET position = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND scale_id = ?
`

type UpdateItemPositionParams struct {
	Position int64
	ID       string
	ScaleID  string
}

func (q *Queries) UpdateItemPosition(ctx context.Context, arg UpdateItemPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateItemPosition, arg.Position, arg.ID, arg.ScaleID)
	return err
}

const updateParticipantEmail = `-- name: UpdateParticipantEmail :exec
UPDATE participants SET email = ?, self_token = self_token WHERE id = ?
`

type UpdateParticipantEmailParams struct {
	Email sql.NullString
	ID    string
}

func (q *Queries) UpdateParticipantEmail(ctx context.Context, arg UpdateParticipantEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateParticipantEmail, arg.Email, arg.ID)
	return err
}

const updateScale = `-- name: UpdateScale :exec
UPDATE scales SET
  points = ?,
  randomize = ?,
  name_i18n = ?,
  consent_i18n = ?,
  collect_email = ?,
  e2ee_enabled = ?,
  region = ?,
  turnstile_enabled = ?,
  items_per_page = ?,
  consent_config = ?,
  likert_labels_i18n = ?,
  likert_show_numbers = ?,
  likert_preset = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateScaleParams struct {
	Points            int64
	Randomize         int64
	NameI18n          sql.NullString
	ConsentI18n       sql.NullString
	CollectEmail      sql.NullString
	E2eeEnabled       int64
	Region            sql.NullString
	TurnstileEnabled  int64
	ItemsPerPage      sql.NullInt64
	ConsentConfig     sql.NullString
	LikertLabelsI18n  sql.NullString
	LikertShowNumbers int64
	LikertPreset      sql.NullString
	ID                string
}

func (q *Queries) UpdateScale(ctx context.Context, arg UpdateScaleParams) error {
	_, err := q.db.ExecContext(ctx, updateScale,
		arg.Points,
		arg.Randomize,
		arg.NameI18n,
		arg.ConsentI18n,
		arg.CollectEmail,
		arg.E2eeEnabled,
		arg.Region,
		arg.TurnstileEnabled,
		arg.ItemsPerPage,
		arg.ConsentConfig,
		arg.LikertLabelsI18n,
		arg.LikertShowNumbers,
		arg.LikertPreset,
		arg.ID,
	)
	return err
}

const upsertAIConfig = `-- name: UpsertAIConfig :exec
INSERT INTO tenant_ai_configs (tenant_id, openai_key, openai_base, allow_external, store_logs, updated_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(tenant_id) DO UPDATE SET
  openai_key = excluded.openai_key,
  openai_base = excluded.openai_base,
  allow_external = excluded.allow_external,
  store_logs = excluded.store_logs,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertAIConfigParams struct {
	TenantID      string
	OpenaiKey     sql.NullString
	OpenaiBase    sql.NullString
	AllowExternal int64
	StoreLogs     int64
}

func (q *Queries) UpsertAIConfig(ctx context.Context, arg UpsertAIConfigParams) error {
	_, err := q.db.ExecContext(ctx, upsertAIConfig,
		arg.TenantID,
		arg.OpenaiKey,
		arg.OpenaiBase,
		arg.AllowExternal,
		arg.StoreLogs,
	)
	return err
}
